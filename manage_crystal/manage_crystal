#!/usr/bin/env python
from __future__ import print_function  #python3 like print()
from __future__ import absolute_import
import string, sys
import numpy as np
from numpy.linalg import inv
import math
import subprocess
import argparse
from argparse import RawTextHelpFormatter  #needed to go next line in the help text
import os
import re  #re.split(r'(\d+)',"O23") = ['O', '23', '']
from six.moves import range
from manage_crystal import Crys
from manage_crystal.atomic_data import *  #import all the data stored in the file atom_data.py
from manage_crystal.file_parser import parse_axsf, parse_cif, parse_cssr
from manage_crystal.file_parser import parse_pdb, parse_poscar, parse_pwo
from manage_crystal.file_parser import parse_xyz, parse_xyz_tm3
#from pprint import pprint #pprint(vars(your_object))

parser = argparse.ArgumentParser(
    description=
    'Program to read, extract info and convert crystal files (by Daniele Ongari)',
    formatter_class=RawTextHelpFormatter)

parser.add_argument(
    "inputfile",
    type=str,
    help="path to the input file to read\n" +
    "IMPLEMENTED: xyz(w/CELL),pdb,cssr,pwi,pwo,cif,xsf,axsf,subsys(CP2K),\n" +
    "             restart(CP2K),inp(CP2K),cube,POSCAR(VASP) \n" +
    "             [NEXT: gaussian, dcd+atoms]")

parser.add_argument(
    "-o",
    "--output",
    action="store",
    type=str,
    dest="output",
    default=None,
    help="Output filename.extension or just the extension\n" +
    "IMPLEMENTED: cif,pdb,cssr,xyz(w/CELL),pwi,subsys(CP2K),axsf")

parser.add_argument(
    "-silent",
    action="store_true",
    dest="silent",
    default=False,
    help="No output info on the screen")

parser.add_argument(
    "-show",
    action="store_true",
    dest="show",
    default=False,
    help="Show all the info\n" + "[skip -silent]")

parser.add_argument(
    "-showonly",
    action="store",
    type=str,
    dest="showonly",
    default=None,
    help="Show only the required info:\n" + "cell, CELL, xyz, fract, charge\n"
    + "[skip -silent]")

parser.add_argument(
    "-cupw",
    action="store_true",
    dest="cupw",
    default=False,
    help="Look for a Copper PaddleWheel")

parser.add_argument(
    "-void",
    action="store_true",
    dest="void",
    default=False,
    help="Compute void geometrically [NOT WORKING]")

parser.add_argument(
    "-ovlp",
    action="store_true",
    dest="ovlp",
    default=False,
    help="Look for an overlap and modify the file [WORK IN PROGRESS]")

parser.add_argument(
    "-pseudopw",
    action="store",
    type=str,
    dest="pseudopw",
    default="pbe",
    help="Pseudo for the .pwi output")

parser.add_argument(
    "-bscp2k",
    action="store",
    type=str,
    dest="bscp2k",
    default="DZVP-MOLOPT-SR-GTH",
    help="Gaussian Basis Set for CP2K")

parser.add_argument(
    "-resp",
    action="store",
    type=str,
    dest="resp",
    default=None,
    help="Read the charges from a cp2k RESP file\n" +
    "(also checking if the atoms are the same)\n" +
    "BC1: it read the first set of charges\n" +
    "BC2: Also a cp2k output file with charges is fine!\n")

parser.add_argument(
    "-readcharge",
    action="store",
    type=str,
    dest="readcharge",
    default=None,
    help="Read the charges from a simple list")

parser.add_argument(
    "-readrepeatcharge",
    action="store",
    type=str,
    dest="readrepeatcharge",
    default=None,
    help="Read the charges from REPEAT output of QE")

parser.add_argument(
    "-x",
    action="store",
    type=int,
    dest="multipl_x",
    default=1,
    help="Extend in the x direction, by the specified times")

parser.add_argument(
    "-y",
    action="store",
    type=int,
    dest="multipl_y",
    default=1,
    help="Extend in the y direction, by the specified times")

parser.add_argument(
    "-z",
    action="store",
    type=int,
    dest="multipl_z",
    default=1,
    help="Extend in the z direction, by the specified times")

parser.add_argument(
    "-cutoff",
    action="store",
    type=float,
    dest="cutoff",
    default=None,
    help="Automatically extend the UC so that the cutoff is respected\n" +
    "(TIP: use -cutoff 0 to just know the perpendicular widths!)")

parser.add_argument(
    "-chargenull",
    action="store_true",
    dest="chargenull",
    default=False,
    help="Delete the charge of the atoms")

parser.add_argument(
    "-printatoms",
    action="store_true",
    dest="printatoms",
    default=False,
    help="Print all atoms types\n" + "[skip -silent]")

parser.add_argument(
    "-printatoms_noHCO",
    action="store_true",
    dest="printatoms_noHCO",
    default=False,
    help="Print all atoms types exc. H,C,O\n" + "[skip -silent]")

parser.add_argument(
    "-transl",
    action="store",
    type=float,
    nargs=3,
    dest="transl",
    default=None,
    help="x y z translation in Angs")

parser.add_argument(
    "-rotaxis",
    choices=[None, "up", "down"],
    dest="rotaxis",
    default=None,
    help="Rotate the axis. 'up': xyz>zxy, 'down': xyz>yzx")

parser.add_argument(
    "-mol",
    action="store_true",
    dest="mol",
    default=False,
    help="Considers a molecule for xyz: no cell!"
)  #to ad later, now putting a 50x50x50 cell is fine!

parser.add_argument(
    "-randomize",
    action="store",
    type=float,
    dest="randomize",
    default=None,
    help="Randomize the geometry by a gaussian\n" +
    "with the specified delta (angs)")

################################################# START stuff for Qeq project-22
parser.add_argument(
    "-chkmetalcharge",
    action="store_true",
    dest="chkmetalcharge",
    default=False,
    help="Check if the charge on a metal (see list) is neg.\n" +
    "[skip -silent]")

parser.add_argument(
    "-chkcharge",
    action="store_true",
    dest="chkcharge",
    default=False,
    help="Check if all the charges are zero.\n" + "[skip -silent]")

parser.add_argument(
    "-chkdef2",
    action="store_true",
    dest="chkdef2",
    default=False,
    help="Check if there is a non def2 BS atom (H-La, Hf-Rn).\n" +
    "[skip -silent]")

parser.add_argument(
    "-chkmepo",
    action="store_true",
    dest="chkmepo",
    default=False,
    help="Check if there is a non MEPO atom (H,V,Cu,Zn,C,N,O,F,Cl,Br,I).\n" +
    "[skip -silent]")

parser.add_argument(
    "-avgcharges",
    action="store_true",
    dest="avgcharges",
    default=False,
    help="Use average charges from DDEC")

parser.add_argument(
    "-normalizecharges",
    action="store_true",
    dest="normalizecharges",
    default=False,
    help="Normalize the charges to have a null total charge.")

################################################### END stuff for Qeq project-22

parser.add_argument(
    "-tm "
    "--tailormade",
    type=int,
    dest="tm",
    default=0,
    help="Tailor made settings for parsing and writing:\n" +
    " 1 - Deprecated (parse DDEC-CoRE-MOF .cif)\n"
    " 2 - Deprecated (write .cif for EQeq)\n"
    " 3 - Parse .xyz for B. Wells Qeq program\n"
    " 4 - Write .xyz for B. Wells Qeq program\n"
    " 5 - Write .xyz for B. Wells Qeq program, w/ zero formal charge\n"
    " 6 - Deprecated (parse .cif from EGULP)\n")

args = parser.parse_args()

###################################################################### UTILITIES

atom_count = [0] * 119  #anything assigned to 0, H_index=1, He_index=2, ...

ANGS2BOHR = 1.88973
AVOGCONST = 6.022E+23


def is_number(s):  #checks if a string is a number or not
    try:
        float(s)
        return True
    except ValueError:
        pass
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass


########################################################################## INPUT
# reading input file: name and format (notice that if there is a path it becomes
# part of the name, to have the output in the same place)
if not os.path.isfile(args.inputfile):
    sys.exit("ERROR: The file %s doesn't exist!" % args.inputfile)
inputfilename = os.path.splitext(args.inputfile)[0]
inputformat = os.path.splitext(args.inputfile)[1][1:]
file = open(inputfilename + "." + inputformat, 'r')
if inputformat in ["axsf", "xsf"]:
    crys = parse_axsf(file)
elif inputformat == "cif":
    crys = parse_cif(file)
elif inputformat in ["subsys", "inp", "restart"]:
    crys = parse_cp2k(file)
elif inputformat == "cssr":
    crys = parse_cssr(file)
elif inputformat == "cube":
    crys = parse_cube(file)
elif inputformat == "pdb":
    crys = parse_pdb(file)
elif inputformat == "POSCAR":
    crys = parse_poscar(file)
elif inputformat in ["pwo", "pwi"]:
    crys = parse_pwo(file)
elif inputformat == "xyz" and args.tm == 0:
    crys = parse_xyz(file)
elif inputformat == "xyz" and args.tm == 3:  # B. Wells Qeq program
    crys = parse_xyz_tm3(file)
else:
    sys.exit("WARNING: Input file format not implemented. EXIT.")
file.close()

crys.after_parse()
######################################################################## Charges

if not args.resp == None:
    if not all(x == 0 for x in crys.atom_charge):
        if not args.silent:
            print(" ... THERE WERE ALREADY CHARGES BUT I'M OVERWRITING THEM!")
    with open(args.resp, "r") as file:
        i = 0
        for line in file:
            data = line.split()
            if len(data) > 3 and data[0] == 'RESP' \
             and data[2] == crys.atom_type[i]:
                crys.atom_charge[i] = float(data[3])
                i += 1
            if i == crys.natom:
                break

if not args.readcharge == None:
    if not all(x == 0 for x in crys.atom_charge):
        if not args.silent:
            print(" ... THERE WERE ALREADY CHARGES BUT I'M OVERWRITING THEM!")
    with open(args.readcharge) as file:
        i = 0
        for line in file:
            crys.atom_charge[i] = float(line.split()[0])
            i += 1

if not args.readrepeatcharge == None:
    if not all(x == 0 for x in crys.atom_charge):
        if not args.silent:
            print(" ... THERE WERE ALREADY CHARGES BUT I'M OVERWRITING THEM!")
    with open(args.readrepeatcharge) as file:
        if not args.silent:
            print("*** CHARGES from QE>REPEAT.out: multiplying by -0.5")
        i = 0
        for line in file:
            data = line.split()
            if (i - 17) >= 0 and (i - 17) < natoms:  # Header of REPEAT.out
                crys.atom_charge[i - 17] = float(data[6]) * (-0.5)
            i += 1

if args.chargenull:
    if not args.silent: print("*** chargenull: DELETING ALL THE CHARGES! ***")
    crys.atom_charge = [0] * crys.natom

if args.normalizecharges:
    if not args.silent: print("")
    if not args.silent: print("*** NORMALIZING CHARGES ***")
    pos_charge = 0
    neg_charge = 0
    for i in range(crys.atom_natoms):
        if crys.atom_charge[i] > 0:
            pos_charge += crys.atom_charge[i]
        else:
            neg_charge += crys.atom_charge[i]

    tot_charge = pos_charge + neg_charge
    tot_abs = pos_charge - neg_charge
    pos_fract = pos_charge / tot_abs

    if not args.silent: print("total charge: %f" % tot_charge)
    if not args.silent: print("positive charges: %f" % pos_charge)
    if not args.silent: print("negative charges: %f" % neg_charge)
    if not args.silent: print("total absolute ch.: %f" % tot_abs)

    for i in range(crys.atom_natoms):
        if crys.atom_charge[i] > 0:
            crys.atom_charge[i] = crys.atom_charge[
                i] - tot_charge * pos_fract * crys.atom_charge[i] / pos_charge
        else:
            crys.atom_charge[i] = crys.atom_charge[i] - tot_charge * (
                1 - pos_fract) * crys.atom_charge[i] / neg_charge

########################################################### Coordinates and cell

if crys.inp_matrix:
    if not args.silent: print("\n Cell parsed as matrix.")
elif crys.inp_lengths_angles:
    if not args.silent: print("\n Cell parsed as lengths and angles.")
crys.compute_both_cell()

if crys.inp_fract:
    if not args.silent: print(" \n Atomic coordinates parsed cartersian.")
elif crys.inp_xyz:
    if not args.silent: print(" \n Atomic coordinates parsed fractional.")
crys.compute_both_coord()

############################################################ Temporary converter
natoms = crys.natom
if crys.inp_lengths_angles:
    ABC = crys.length
    abc = crys.angle_rad
elif crys.inp_matrix:
    cell = np.matrix(crys.matrix)
if crys.inp_xyz:
    xyz = crys.atom_xyz
elif crys.inp_fract:
    fract = crys.atom_fract
atom = crys.atom_element
an = crys.atom_atnum
for f in an:
    atom_count[f] += 1
charge = crys.atom_charge
############################################################################ APPLY TRANSLATION / RANDOMIZE
if args.transl != None:

    if not args.silent: print()
    if not args.silent:
        print("*** TRANSLATING coordinates by %f %f %f Angs" %
              (args.transl[0], args.transl[1], args.transl[2]))

    xyz_transl = []
    for i in range(0, natoms):
        x = xyz[i][0] + args.transl[0]
        y = xyz[i][1] + args.transl[1]
        z = xyz[i][2] + args.transl[2]
        xyz_transl.append([x, y, z])
    xyz = xyz_transl  #overwrite old xyz

    fract = []  #clear old fract
    for i in range(0, natoms):
        x = xyz[i][0] * invcell.item((0, 0)) + xyz[i][1] * invcell.item(
            (1, 0)) + xyz[i][2] * invcell.item((2, 0))
        y = xyz[i][1] * invcell.item((0, 1)) + xyz[i][1] * invcell.item(
            (1, 1)) + xyz[i][2] * invcell.item((2, 1))
        z = xyz[i][2] * invcell.item((0, 2)) + xyz[i][1] * invcell.item(
            (1, 2)) + xyz[i][2] * invcell.item((2, 2))
        fract.append([x, y, z])

if args.rotaxis != None:

    if not args.silent: print()
    if not args.silent:
        print("*** ROTATING axis, direction: %r" % args.rotaxis)
    if not args.silent: print("*** Warning: the cell matrix is not rotated")
    if args.rotaxis == "up":
        ABC[0], ABC[1], ABC[2] = ABC[2], ABC[0], ABC[1]
        abc[0], abc[1], abc[2] = abc[2], abc[0], abc[1]
        for i in range(natoms):
            xyz[i][0], xyz[i][1], xyz[i][2] = xyz[i][2], xyz[i][0], xyz[i][1]
            fract[i][0], fract[i][1], fract[i][2] = \
             fract[i][2], fract[i][0], fract[i][1]

    if args.rotaxis == "down":
        ABC[0], ABC[1], ABC[2] = ABC[1], ABC[2], ABC[0]
        abc[0], abc[1], abc[2] = abc[1], abc[2], abc[0]
        for i in range(natoms):
            xyz[i][0], xyz[i][1], xyz[i][2] = xyz[i][1], xyz[i][2], xyz[i][0]
            fract[i][0], fract[i][1], fract[i][2] = \
             fract[i][1], fract[i][2], fract[i][0]

if args.randomize != None:

    if not args.silent: print()
    if not args.silent:
        print(
            "*** RANDOMIZING XYZ coordinates by a normal distrib with delta=%f Angs"
            % args.randomize)

    xyz_random = []
    for i in range(0, natoms):
        x = xyz[i][0] + np.random.normal(0, args.randomize, 1)
        y = xyz[i][1] + np.random.normal(0, args.randomize, 1)
        z = xyz[i][2] + np.random.normal(0, args.randomize, 1)
        xyz_random.append([x, y, z])
    xyz = xyz_random  #overwrite old xyz

    fract = []  #clear old fract
    for i in range(0, natoms):
        x = float(
            xyz[i][0] * invcell.item((0, 0)) + xyz[i][1] * invcell.item(
                (1, 0)) + xyz[i][2] * invcell.item((2, 0))
        )  #no clear why float is needed here: otherwise it is considered a str
        y = float(xyz[i][1] * invcell.item((0, 1)) + xyz[i][1] * invcell.item(
            (1, 1)) + xyz[i][2] * invcell.item((2, 1)))
        z = float(xyz[i][2] * invcell.item((0, 2)) + xyz[i][1] * invcell.item(
            (1, 2)) + xyz[i][2] * invcell.item((2, 2)))
        fract.append([x, y, z])

############################################################################# CUTOFF TEST
if not args.cutoff == None:  #copied from raspa/framework.c/CellProperties(line:6184)

    if args.multipl_x > 1 or args.multipl_y > 1 or args.multipl_z > 1:
        sys.exit("Why did you ask for both -cutoff and -x -y -z ????")

    ax = cell.item((0, 0))
    ay = cell.item((0, 1))
    az = cell.item((0, 2))
    bx = cell.item((1, 0))
    by = cell.item((1, 1))
    bz = cell.item((1, 2))
    cx = cell.item((2, 0))
    cy = cell.item((2, 1))
    cz = cell.item((2, 2))

    # calculate vector products of cell vectors
    axb1 = ay * bz - az * by
    axb2 = az * bx - ax * bz
    axb3 = ax * by - ay * bx

    bxc1 = by * cz - bz * cy
    bxc2 = bz * cx - bx * cz
    bxc3 = bx * cy - by * cx

    cxa1 = cy * az - ay * cz
    cxa2 = ax * cz - az * cx
    cxa3 = ay * cx - ax * cy

    # calculate volume of cell
    VOLUME = math.fabs(ax * bxc1 + ay * bxc2 + az * bxc3)

    # calculate cell perpendicular widths
    perp_x = VOLUME / math.sqrt(bxc1**2 + bxc2**2 + bxc3**2)
    perp_y = VOLUME / math.sqrt(cxa1**2 + cxa2**2 + cxa3**2)
    perp_z = VOLUME / math.sqrt(axb1**2 + axb2**2 + axb3**2)

    print()
    print("CUTOFF_TEST | Cutoff: %.1f" % (args.cutoff))
    print("CUTOFF_TEST | Cell perpendicular widths: %.3f %.3f %.3f" %
          (perp_x, perp_y, perp_z))

    # compute how big the cell must be
    args.multipl_x = int(math.ceil(2 * args.cutoff / perp_x))
    args.multipl_y = int(math.ceil(2 * args.cutoff / perp_y))
    args.multipl_z = int(math.ceil(2 * args.cutoff / perp_z))

    if args.multipl_x > 1 or args.multipl_y > 1 or args.multipl_z > 1:
        print("CUTOFF_TEST | Expansion_done: %d %d %d for %s" %
              (args.multipl_x, args.multipl_y, args.multipl_z, args.inputfile))
    else:
        print("CUTOFF_TEST | Expansion_unnecesary: 1 1 1 for %s" %
              (args.inputfile))

############################################################################# CELL EXTENSION
if args.multipl_x > 1 or args.multipl_y > 1 or args.multipl_z > 1:

    if args.multipl_x > 1:
        for i in range(1, args.multipl_x):
            for j in range(0, natoms):
                atom.append(atom[j])
                an.append(atomic_symbol.index(atom[j]))
                atom_count[an[j]] += 1
                charge.append(charge[j])
                xyz.append([
                    xyz[j][0] + i * cell[0, 0], xyz[j][1] + i * cell[0, 1],
                    xyz[j][2] + i * cell[0, 2]
                ])
        ABC[0] *= args.multipl_x
        cell[0, 0] *= args.multipl_x  #nonzero
        cell[0, 1] *= args.multipl_x  #zero
        cell[0, 2] *= args.multipl_x  #zero
        natoms *= args.multipl_x

    if args.multipl_y > 1:
        for i in range(1, args.multipl_y):
            for j in range(0, natoms):
                atom.append(atom[j])
                an.append(atomic_symbol.index(atom[j]))
                atom_count[an[j]] += 1
                charge.append(charge[j])
                xyz.append([
                    xyz[j][0] + i * cell[1, 0], xyz[j][1] + i * cell[1, 1],
                    xyz[j][2] + i * cell[1, 2]
                ])
        ABC[1] *= args.multipl_y
        cell[1, 0] *= args.multipl_y  #nonzero
        cell[1, 1] *= args.multipl_y  #nonzero
        cell[1, 2] *= args.multipl_y  #zero
        natoms *= args.multipl_y

    if args.multipl_z > 1:
        for i in range(1, args.multipl_z):
            for j in range(0, natoms):
                atom.append(atom[j])
                an.append(atomic_symbol.index(atom[j]))
                atom_count[an[j]] += 1
                charge.append(charge[j])
                xyz.append([
                    xyz[j][0] + i * cell[2, 0], xyz[j][1] + i * cell[2, 1],
                    xyz[j][2] + i * cell[2, 2]
                ])
        ABC[2] *= args.multipl_z
        cell[2, 0] *= args.multipl_z  #nonzero
        cell[2, 1] *= args.multipl_z  #nonzero
        cell[2, 2] *= args.multipl_z  #nonzero
        natoms *= args.multipl_z

    fract = []
    invcell = inv(cell)
    for i in range(0, natoms):
        x = xyz[i][0] * invcell[0, 0] + xyz[i][1] * invcell[1, 0] + xyz[i][
            2] * invcell[2, 0]
        y = xyz[i][1] * invcell[0, 1] + xyz[i][1] * invcell[1, 1] + xyz[i][
            2] * invcell[2, 1]
        z = xyz[i][2] * invcell[0, 2] + xyz[i][1] * invcell[1, 2] + xyz[i][
            2] * invcell[2, 2]
        fract.append([x, y, z])

########################################################################################### COMPUTE INFO
# count atoms
if not args.silent: print()
ntypes = 0
for i in range(0, len(atom_count)):
    if atom_count[i] != 0:
        ntypes += 1
        if not args.silent:
            print('{0:>5} {1:3} atoms'.format(atom_count[i], atomic_symbol[i]))

if not args.silent: print(" ---- --- ----- ")
if not args.silent: print('{0:>5} {1:3} atoms'.format(natoms, 'tot'))

#compute volume (http://www.fxsolver.com/browse/formulas/Triclinic+crystal+system+(Unit+cell's+volume))
volume = ABC[0] * ABC[1] * ABC[2] * math.sqrt(
    1 - (math.cos(abc[0]))**2 - (math.cos(abc[1]))**2 - (math.cos(abc[2]))**2 +
    2 * math.cos(abc[0]) * math.cos(abc[1]) * math.cos(abc[2]))
if not args.silent: print()
if not args.silent: print("Volume: %.3f (Angtrom^3/u.c.)" % volume)

#compute density
weight = 0
for i in range(0, len(atom_count)):
    if atom_count[i] != 0:
        weight += atom_count[i] * atomic_mass[i]  #g/mol_uc
rho = weight / volume / AVOGCONST * 1E+10**3 / 1000  #Kg/m3
if not args.silent:
    print(
        "Density: %.5f (kg/m3), %.5f (g/cm3), %.5f (g/molUC)" %
        (rho, rho / 1000, weight), )

#compute conversion to mol/kg
molkg = 1000 / weight  #mol/g
if not args.silent:
    print("Conversion: 1 molec./u.c. = %.5f (mol/kg)" % (molkg))

#check the NET_CHARGE
if not args.silent: print()
#if not args.silent: print("Net charge: %.10f" %sum(charge))
if sum(charge) == 0 and max(charge) < 0.001:
    if not args.silent: print("NET_CHARGE: all the charges are zero.")
elif sum(charge) > -0.001 and sum(charge) < +0.001:
    if not args.silent: print("NET_CHARGE: negligible (|sum|<0.001).")
    #charge[0]=charge[0]-sum(charge)
    #print("*** Negligible error due to the rounding: subtracted from the first atom!")
    #print("*** Now the net charge is %.10f" %sum(charge))
else:
    if not args.silent:
        print("NET_CHARGE: nonzero (%.3f). ***WARNING***" % sum(charge))

#check negative charge on metals [skip -silent]
if args.chkmetalcharge:
    metal_list = [
        "Li", "Be", "Na", "Mg", "Al", "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn",
        "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Rb", "Sr", "Y", "Zr", "Nb", "Mo",
        "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Cs", "Ba", "La", "Hf",
        "Ta", "W"
    ]
    found_met = False
    found_met_neg = False
    found_met_nonzero = False
    found_met_notnumber = False
    for i in range(0, natoms):
        if (atom[i] in metal_list):
            found_met = True
            if math.isnan(charge[i]):
                print("CHK_METAL_CHARGE: not_number >>> %s=%s" % (atom[i],
                                                                  charge[i]))
                found_met_notnumber = True
            elif charge[i] < 0:
                print("CHK_METAL_CHARGE: found_negative >>> %s=%.3f" %
                      (atom[i], charge[i]))
                found_met_neg = True
            elif charge[i] > 0:
                found_met_nonzero = True
        if found_met_notnumber or found_met_neg: break
    if not found_met: print("CHK_METAL_CHARGE: no_metals")
    if found_met and not found_met_neg and not found_met_notnumber and not found_met_nonzero:
        print("CHK_METAL_CHARGE: all_zero")
    if found_met and not found_met_neg and not found_met_notnumber and found_met_nonzero:
        print("CHK_METAL_CHARGE: ok_positive")

#check if the charges are assigned / all zero / nan [skip -silent]
if args.chkcharge:
    found_nonzero = False
    found_notnumber = False
    found_weird = False
    for i in range(0, natoms):
        if math.isnan(charge[i]):
            print("CHK_CHARGE: not_number >>> %s=%s" % (atom[i], charge[i]))
            found_notnumber = True
            break
        elif charge[i] > 3 or charge[i] < -3:
            found_weird = True
            print("CHK_CHARGE: weird_charges")
            break
        elif charge[i] != 0:
            found_nonzero = True
            print("CHK_CHARGE: charged_framework")
            break
    if not found_notnumber and not found_weird and not found_nonzero:
        print("CHK_CHARGE: all_zero")

#check non-def2 atoms [skip -silent]
if args.chkdef2:
    found_nondef2 = False
    for i in range(0, natoms):
        if 58 <= an[i] <= 71 or an[i] >= 87:
            found_nondef2 = True
            print("CHK_def2: found %s" % atom[i])
            break
    if not found_nondef2: print("CHK_def2: ok")

#check non-mepo atoms [skip -silent]
if args.chkmepo:
    mepo_list = ["H", "V", "Cu", "Zn", "C", "N", "O", "F", "Cl", "Br", "I"]
    found_nonmepo = False
    for i in range(0, natoms):
        if not (atom[i] in mepo_list):
            found_nonmepo = True
            print("CHK_mepo: found %s" % atom[i])
            break
    if not found_nonmepo: print("CHK_mepo: ok")

#number of electrons
nelectrons = 0
for i in range(0, len(atom_count)):
    if atom_count[i] != 0:
        nelectrons += atom_count[i] * i  #nuber_of_atoms_with_AN*AN
if not args.silent: print("Tot. electrons: %d" % nelectrons)

#print atoms on one line for info
if args.printatoms:
    for i in range(0, len(atom_count)):
        if atom_count[i] != 0:
            print(atomic_symbol[i], end='_')
    print("")
if args.printatoms_noHCO:
    for i in range(0, len(atom_count)):
        if atom_count[i] != 0 and atomic_symbol[i]!="H" \
                                     and atomic_symbol[i]!="C" \
                                     and atomic_symbol[i]!="O":
            print(atomic_symbol[i], end='_')
    print("")
################################################################################################# OUTPUT OPERATIONS
if args.output == None:  #CHECK IF AN OUTPUT IS DEFINED
    outputfile = 'NOTHING'
else:
    if len(args.output.split(".")) > 1:  #output defined as name.format
        outputfilename = os.path.splitext(args.output)[0]
        outputformat = os.path.splitext(args.output)[1][1:]
        outputfile = outputfilename + "." + outputformat
    else:  #output defined as format
        outputfilename = inputfilename
        outputformat = args.output
        outputfile = outputfilename + "." + outputformat

if not args.silent: print()
if not args.silent:
    print("***************************************************")
if not args.silent:
    print("  Converting %s to %s" % (inputfilename + "." + inputformat,
                                     outputfile))
if not args.silent:
    print("***************************************************")
if not args.silent: print()

#show and showonly
if args.show:
    print(
        "cell ---------------------------------------------------------------")
if args.show or args.showonly == "cell":
    print("     %10.5f %10.5f %10.5f" % (cell.item((0, 0)), cell.item(
        (0, 1)), cell.item((0, 2))))
if args.show or args.showonly == "cell":
    print("     %10.5f %10.5f %10.5f" % (cell.item((1, 0)), cell.item(
        (1, 1)), cell.item((1, 2))))
if args.show or args.showonly == "cell":
    print("     %10.5f %10.5f %10.5f" % (cell.item((2, 0)), cell.item(
        (2, 1)), cell.item((2, 2))))
if args.show:
    print(
        "CELL (ABC, abc) ----------------------------------------------------")
if args.show or args.showonly == "CELL":
    print(" %10.5f  %10.5f  %10.5f  %10.5f  %10.5f  %10.5f  " %
          (ABC[0], ABC[1], ABC[2], math.degrees(abc[0]), math.degrees(abc[1]),
           math.degrees(abc[2])))
if args.show:
    print(
        "xyz ----------------------------------------------------------------")
if args.show or args.showonly == "xyz":
    for i in range(0, natoms):
        print("%3s %10.5f %10.5f %10.5f " % (atom[i], xyz[i][0], xyz[i][1],
                                             xyz[i][2]))
if args.show:
    print(
        "fract --------------------------------------------------------------")
if args.show or args.showonly == "fract":
    for i in range(0, natoms):
        print("%3s %10.5f %10.5f %10.5f " % (atom[i], fract[i][0], fract[i][1],
                                             fract[i][2]))
if args.show:
    print(
        "charges --------------------------------------------------------------"
    )
if args.show or args.showonly == "charge":
    for i in range(0, natoms):
        print("%3s %10.5f " % (atom[i], charge[i]))
if args.show or args.showonly != None: sys.exit()

#computing void matematically: not working because of three spheres overlapping
if args.void:
    volsphere = 0
    volumeocc = 0
    d = [0] * 3
    s = [0] * 3
    t = [0] * 3
    for i in range(0, natoms):
        Ri = atomic_vdw_UFF[an[i]]
        volsphere += (4. / 3.) * math.pi * (Ri**3)
        volumeocc += (4. / 3.) * math.pi * (Ri**3)
        for j in range((i + 1), natoms):
            Rj = atomic_vdw_UFF[an[j]]

            d[0] = xyz[i][0] - xyz[j][0]
            d[1] = xyz[i][1] - xyz[j][1]
            d[2] = xyz[i][2] - xyz[j][2]

            s[0] = invcell.item((0, 0)) * d[0] + invcell.item(
                (1, 0)) * d[1] + invcell.item((2, 0)) * d[2]
            s[1] = invcell.item((0, 1)) * d[0] + invcell.item(
                (1, 1)) * d[1] + invcell.item((2, 1)) * d[2]
            s[2] = invcell.item((0, 2)) * d[0] + invcell.item(
                (1, 2)) * d[1] + invcell.item((2, 2)) * d[2]

            t[0] = s[0] - int(round(s[0]))
            t[1] = s[1] - int(round(s[1]))
            t[2] = s[2] - int(round(s[2]))

            d[0] = cell.item((0, 0)) * t[0] + cell.item(
                (1, 0)) * t[1] + cell.item((2, 0)) * t[2]
            d[1] = cell.item((0, 1)) * t[0] + cell.item(
                (1, 1)) * t[1] + cell.item((2, 1)) * t[2]
            d[2] = cell.item((0, 2)) * t[0] + cell.item(
                (1, 2)) * t[1] + cell.item((2, 2)) * t[2]

            mindist = math.sqrt(d[0]**2 + d[1]**2 + d[2]**2)

            if (Ri + Rj < mindist): V_ovlp = 0
            else:
                V_ovlp = math.pi * (Ri + Rj - mindist)**2 * (
                    mindist**2 + 2 * mindist * Rj - 3 * Rj**2 + 2 * mindist *
                    Ri + 6 * Rj * Ri - 3 * Ri**2) / (12. * mindist)
            volumeocc -= V_ovlp  #works only if there are not three spheres with a common overlapping

#print("Volume without atom spheres:  %.3f (Angtrom^3/u.c.)" %(volume-volumeocc))
    print("Void fraction (cons. ovlp):       %.6f [= %.3f non-void (A^3)]" %
          (1 - volumeocc / volume, volumeocc))
    print("Void fraction (negl. ovlp):       %.6f [= %.3f non-void (A^3)]" %
          (1 - volsphere / volume, volsphere))
    print()
    #sys.exit("YOU JUST ASKED for VOID: no external files printed!")
    sys.exit()

#This function checks if there are copper paddlewheels (= a copper atom with a close Cu and 4 close O)
if args.cupw:
    ncupw_act = 0
    ncupw_sol = 0
    ncupw_wrd = 0
    for i in range(0, natoms):
        closeCu = 0
        closeO = 0
        closeX = 0

        if (an[i] == 29):
            for j in range(0, natoms):
                if (j != i):
                    d = [0] * 3
                    s = [0] * 3
                    t = [0] * 3

                    #d[0]=xyz[i][0]-xyz[j][0]
                    #d[1]=xyz[i][1]-xyz[j][1]
                    #d[2]=xyz[i][2]-xyz[j][2]
                    #s[0]=invcell.item((0,0))*d[0]+invcell.item((1,0))*d[1]+invcell.item((2,0))*d[2]
                    #s[1]=invcell.item((0,1))*d[0]+invcell.item((1,1))*d[1]+invcell.item((2,1))*d[2]
                    #s[2]=invcell.item((0,2))*d[0]+invcell.item((1,2))*d[1]+invcell.item((2,2))*d[2]

                    s[0] = fract[i][0] - fract[j][0]
                    s[1] = fract[i][1] - fract[j][1]
                    s[2] = fract[i][2] - fract[j][2]

                    t[0] = s[0] - int(round(s[0]))
                    t[1] = s[1] - int(round(s[1]))
                    t[2] = s[2] - int(round(s[2]))

                    d[0] = cell.item((0, 0)) * t[0] + cell.item(
                        (1, 0)) * t[1] + cell.item((2, 0)) * t[2]
                    d[1] = cell.item((0, 1)) * t[0] + cell.item(
                        (1, 1)) * t[1] + cell.item((2, 1)) * t[2]
                    d[2] = cell.item((0, 2)) * t[0] + cell.item(
                        (1, 2)) * t[1] + cell.item((2, 2)) * t[2]

                    mindist = math.sqrt(d[0]**2 + d[1]**2 + d[2]**2)

                    if (an[j] == 29) and (1.8 < mindist < 2.8):
                        closeCu += 1
                        #print("%d %d %f     %d %d" %(i,j,mindist,closeO,closeX)
                    if (an[j] == 8) and (1.5 < mindist < 2.5): closeO += 1
                    if (an[j] != 29) and (an[j] != 8) and (1.8 < mindist <
                                                           2.5):
                        closeX += 1
                        #print("%d %d %s  %f------%f %f %f " %(i,j,an[j],mindist,s[0],s[1],s[2]); print(fract[i]; print(fract[j]

            if (closeCu == 1) and (closeO == 4):
                ncupw_act += 1
                #elif (closeCu==1) and (closeO==4) and (closeX>0):  ncupw_sol+=1
            elif (closeCu == 1) and (closeO == 5):
                ncupw_sol += 1
            elif (closeCu < 0):
                ncupw_wrd += 1

    print("Cu-paddlewheel activated found:    %d" % ncupw_act)
    print(
        "Cu-paddlewheel solvated  found:    %d   (only Oxygen atoms considered)"
        % ncupw_sol)
    print("Cu-paddlewheel WEIRD     found:    %d" % ncupw_wrd)
    print()

    #print that I found it
    if True:
        ofile = open("000_cupw_found.txt", 'a')
        if (ncupw_act > 0) or (ncupw_act > 0) or (ncupw_wrd < 0):
            print(args.inputfile, file=ofile)
            print(
                "Cu-paddlewheel activated found:    %d" % ncupw_act,
                file=ofile)
            print(
                "Cu-paddlewheel solvated  found:    %d   (only Oxygen atoms considered)"
                % ncupw_sol,
                file=ofile)
            print(
                "Cu-paddlewheel WEIRD     found:    %d" % ncupw_wrd,
                file=ofile)
            print(" ", file=ofile)

    sys.exit()

#This function checks if two atoms overlap because of a bad PBC wrap
if args.ovlp:
    jlist = []
    for i in range(0, natoms):
        for j in range(i + 1, natoms):
            d = [0] * 3
            s = [0] * 3
            t = [0] * 3

            s[0] = fract[i][0] - fract[j][0]
            s[1] = fract[i][1] - fract[j][1]
            s[2] = fract[i][2] - fract[j][2]

            t[0] = s[0] - int(round(s[0]))
            t[1] = s[1] - int(round(s[1]))
            t[2] = s[2] - int(round(s[2]))

            d[0] = cell.item((0, 0)) * t[0] + cell.item(
                (1, 0)) * t[1] + cell.item((2, 0)) * t[2]
            d[1] = cell.item((0, 1)) * t[0] + cell.item(
                (1, 1)) * t[1] + cell.item((2, 1)) * t[2]
            d[2] = cell.item((0, 2)) * t[0] + cell.item(
                (1, 2)) * t[1] + cell.item((2, 2)) * t[2]

            mindist = math.sqrt(d[0]**2 + d[1]**2 + d[2]**2)

            if (mindist < 0.2):
                print("Overlap found between:")
                print("%3s %9.5f %9.5f %9.5f " % (atom[i], xyz[i][0],
                                                  xyz[i][1], xyz[i][2]))
                print("%3s %9.5f %9.5f %9.5f " % (atom[j], xyz[j][0],
                                                  xyz[j][1], xyz[j][2]))
                if atom[i] == atom[
                        j]:  #the two atoms are the same and they are overlapping
                    jlist.append(j)
                else:  #something weird is happening, two different atoms are overlapping
                    print(
                        "!!!!!! CHECK THE CRYSTAL, DIFFERENT ATOMS OVERLAPPING !!!!!!"
                    )
                    sys.exit(
                        "!!!!!! CHECK THE CRYSTAL, DIFFERENT ATOMS OVERLAPPING !!!!!!"
                    )

    if len(jlist) > 0:  #correct overlaps
        natoms = natoms - len(jlist)
        atom = [i for j, i in enumerate(atom) if j not in jlist]
        an = [i for j, i in enumerate(an) if j not in jlist]
        xyz = [i for j, i in enumerate(xyz) if j not in jlist]
        fract = [i for j, i in enumerate(fract) if j not in jlist]
        charge = [i for j, i in enumerate(charge) if j not in jlist]
        print("OVERLAPS FOUND: %d" % len(jlist))
        #continue and overwrite the file
        outputfile = args.inputfile
        outputformat = args.inputfile.split(".")[-1]
    else:
        print("OVERLAPS FOUND: %d" % len(jlist))
        sys.exit()

############################################################################## Write converted files
if args.output != None:

    ofile = open(outputfile, 'w+')

    if outputformat == "cif":
        print("data_crystal", file=ofile)
        print(" ", file=ofile)
        print("_cell_length_a    %.5f" % ABC[0], file=ofile)
        print("_cell_length_b    %.5f" % ABC[1], file=ofile)
        print("_cell_length_c    %.5f" % ABC[2], file=ofile)
        print("_cell_angle_alpha %.5f" % math.degrees(abc[0]), file=ofile)
        print("_cell_angle_beta  %.5f" % math.degrees(abc[1]), file=ofile)
        print("_cell_angle_gamma %.5f" % math.degrees(abc[2]), file=ofile)
        print(" ", file=ofile)
        print("_symmetry_space_group_name_Hall 'P 1'", file=ofile)
        print("_symmetry_space_group_name_H-M  'P 1'", file=ofile)
        print(" ", file=ofile)
        print("loop_", file=ofile)
        print("_symmetry_equiv_pos_as_xyz", file=ofile)
        print(" 'x,y,z' ", file=ofile)
        print(" ", file=ofile)
        print("loop_", file=ofile)
        print("_atom_site_label", file=ofile)
        print("_atom_site_type_symbol", file=ofile)
        print("_atom_site_fract_x", file=ofile)
        print("_atom_site_fract_y", file=ofile)
        print("_atom_site_fract_z", file=ofile)
        print("_atom_site_charge", file=ofile)
        for i in range(0, natoms):
            label = atom[
                i]  #removed: label=atom[i]+"_"+str(i+1) because the number makes Raspa extremely verbose
            print(('{0:10} {1:5} {2:>9.5f} {3:>9.5f} {4:>9.5f} {5:>14.10f}'.
                   format(label, atom[i], fract[i][0], fract[i][1],
                          fract[i][2], charge[i])),
                  file=ofile)
    #Better to keep a lot of decimals to avoid small net charged

    elif outputformat == "pdb":
        print((
            'CRYST1{0:>9.3f}{1:>9.3f}{2:>9.3f}{3:>7.2f}{4:>7.2f}{5:>7.2f} P 1           1'
            .format(ABC[0], ABC[1], ABC[2], math.degrees(abc[0]),
                    math.degrees(abc[1]), math.degrees(abc[2]))),
              file=ofile)
        for i in range(0, natoms):
            print(
                "%-6s%5d %4s%1s%3s %1s%4d%1s   %8.5f%8.5f%8.5f%6.2f%6.2f          %2s%2s"
                % ("ATOM", i + 1, atom[i], "", "XXX", "X", 1, "", fract[i][0],
                   fract[i][1], fract[i][2], 1.00, 0.00, atom[i], ""),
                file=ofile)

    elif outputformat == "cssr":
        print(
            "                               %.3f  %.3f  %.3f" %
            (ABC[0], ABC[1], ABC[2]),
            file=ofile)
        print(
            "                %.3f   %.3f   %.3f   SPGR =  1 P 1         OPT = 1"
            % (math.degrees(abc[0]), math.degrees(abc[1]), math.degrees(
                abc[2])),
            file=ofile)
        print("%d   0" % (natoms), file=ofile)
        print("0 %s       : %s" % (inputfilename, inputfilename), file=ofile)
        for i in range(0, natoms):
            print(
                "%4d %3s %8.5f %8.5f %8.5f    0  0  0  0  0  0  0  0  %7.5f" %
                (i + 1, atom[i], fract[i][0], fract[i][1], fract[i][2],
                 charge[i]),
                file=ofile)

    elif outputformat == "xyz" and args.tm == 0:
        print("%d" % (natoms), file=ofile)
        print(
            "CELL:  %.5f  %.5f  %.5f  %.3f  %.3f  %.3f  "
            % (ABC[0], ABC[1], ABC[2], math.degrees(abc[0]),
               math.degrees(abc[1]), math.degrees(abc[2])),
            file=ofile)
        for i in range(0, natoms):
            print(
                "%3s %9.5f %9.5f %9.5f " % (atom[i], xyz[i][0], xyz[i][1],
                                            xyz[i][2]),
                file=ofile)
    elif outputformat == "xyz" and args.tm == 4:
        print(
            "****PRINTING .xyz TAILOR-MADE4 FOR Qeq program by B.Wells***",
            file=ofile)
        print(
            "      FRAC       %.5f  %.5f  %.5f  %.3f  %.3f  %.3f  "
            % (ABC[0], ABC[1], ABC[2], math.degrees(abc[0]),
               math.degrees(abc[1]), math.degrees(abc[2])),
            file=ofile)
        print("%d" % (natoms), file=ofile)
        for i in range(0, natoms):
            print(
                "%3s %9.5f %9.5f %9.5f " % (atom[i], fract[i][0], fract[i][1],
                                            fract[i][2]),
                file=ofile)
    elif outputformat == "xyz" and args.tm == 5:
        print(
            "****PRINTING .xyz TAILOR-MADE5 FOR Qeq program by B.Wells (with FC=0)***",
            file=ofile)
        print(
            "      FRAC       %.5f  %.5f  %.5f  %.3f  %.3f  %.3f  "
            % (ABC[0], ABC[1], ABC[2], math.degrees(abc[0]),
               math.degrees(abc[1]), math.degrees(abc[2])),
            file=ofile)
        print("%d" % (natoms), file=ofile)
        for i in range(0, natoms):
            print(
                "%3s %9.5f %9.5f %9.5f   xx   0.000   0.000" %
                (atom[i], fract[i][0], fract[i][1], fract[i][2]),
                file=ofile)

    elif outputformat == "pwi":
        if not args.silent:
            print("QE input .pwi using the pseudo: %s" % (args.pseudopw))
        if not args.silent: print()
        print(" &CONTROL ", file=ofile)
        print("    calculation = 'vc-relax' ", file=ofile)
        print("    verbosity   = 'high' ", file=ofile)
        print("    !restart_mode= 'restart' ", file=ofile)
        print("    wf_collect  = .true. ", file=ofile)
        print("    outdir      = './' ", file=ofile)
        print("    prefix      = 'pwscf' ", file=ofile)
        print(
            "    pseudo_dir  = '/scratch/ongari/0_LIBRARIES/2_espresso/%s.1.0.0' "
            % (args.pseudopw),
            file=ofile)
        print("      !nstep        = 50", file=ofile)
        print(
            "      !etot_conv_thr= 1.0D-4", file=ofile
        )  # Note that etot_conv_thr is extensive: it can be hard to converge for big systems!
        print(
            "      !forc_conv_thr= 1.0D-3", file=ofile
        )  # Note that forc_conv_thr is intensive: Ok if max_forc < forc_conv_thr.
        print("    !max_seconds  = 3500", file=ofile)
        print("    !disk_io      = 'none'", file=ofile)
        print(" / ", file=ofile)
        print(" &SYSTEM ", file=ofile)
        print("    ibrav = 0 ", file=ofile)
        print("    nat   = %d " % (natoms), file=ofile)
        print("    ntyp  = %d " % (ntypes), file=ofile)
        print("    !nosym  = .true. ", file=ofile)
        print("      ecutwfc = 70 ", file=ofile)
        print("      ecutrho = 350 ", file=ofile)
        print("    occupations = 'smearing' ", file=ofile)
        print("    smearing    = 'gaussian' ", file=ofile)
        print("    degauss     = 0.02 ", file=ofile)
        print("      tot_charge                 = 0.0 ", file=ofile)
        print("      nspin                      = 1 ", file=ofile)
        print("      tot_magnetization          = -1 ", file=ofile)
        print("      !starting_magnetization(i) = +0.1 ", file=ofile)
        print("    !vdw_corr    = 'grimme-d2' ", file=ofile)
        print(
            "    !input_dft   = 'vdw-df2-b86r' ", file=ofile
        )  # REMEMBER TO: generate_vdW_kernel_table.x     (vc-relax not implemented for nspin>1)
        print(
            "    !input_dft   = 'rvv10' ", file=ofile
        )  # REMEMBER TO: generate_rVV10_kernel_table.x   (vc-relax ok)
        print(" / ", file=ofile)
        print(" &ELECTRONS ", file=ofile)
        print("    scf_must_converge = .false. ", file=ofile)
        print("    electron_maxstep  = 100 ", file=ofile)
        print("    conv_thr          = 1.0d-6 ", file=ofile)
        print("    mixing_mode       = 'local-TF' ", file=ofile)
        print("    mixing_beta       = 0.7 ", file=ofile)
        print("    diagonalization   = 'david' ", file=ofile)
        print(" / ", file=ofile)
        print(" &IONS ", file=ofile)
        print("    ion_dynamics = 'bfgs' ", file=ofile)
        print(" / ", file=ofile)
        print(" &CELL ", file=ofile)
        print("    cell_dynamics  = 'bfgs' ", file=ofile)
        print("    press          = 0.0 ", file=ofile)
        print(
            "    !cell_factor    = 2.0 ", file=ofile
        )  #default: 1.0 for all, 2.0 for vc-relax/md (Not enough space allocated for radial FFT: try restarting with a larger cell_factor.)
        print("    press_conv_thr = 0.5 ", file=ofile)
        print("    cell_dofree    = 'all' ", file=ofile)
        print(" / ", file=ofile)
        print("ATOMIC_SPECIES ", file=ofile)
        for i in range(0, len(atom_count)):
            if atom_count[i] != 0:
                print(
                    "%3s %8.3f  %s" % (atomic_symbol[i], atomic_mass[i],
                                       atomic_pseudo[args.pseudopw][i]),
                    file=ofile)  #add pseudo!
        print(" ", file=ofile)
        print("K_POINTS gamma ", file=ofile)
        print(" ", file=ofile)
        print(
            "CELL_PARAMETERS angstrom ", file=ofile
        )  #It should be very precise (http://pw_forum.pwscf.narkive.com/26uqaajr/crash-in-routine-set-sym-bl)
        print(
            "%11.8f %11.8f %11.8f" % (cell.item((0, 0)), cell.item(
                (0, 1)), cell.item((0, 2))),
            file=ofile)
        print(
            "%11.8f %11.8f %11.8f" % (cell.item((1, 0)), cell.item(
                (1, 1)), cell.item((1, 2))),
            file=ofile)
        print(
            "%11.8f %11.8f %11.8f" % (cell.item((2, 0)), cell.item(
                (2, 1)), cell.item((2, 2))),
            file=ofile)
        print(" ", file=ofile)
        print("ATOMIC_POSITIONS angstrom ", file=ofile)
        for i in range(0, natoms):
            print(
                "%3s %12.8f %12.8f %12.8f " % (atom[i], xyz[i][0], xyz[i][1],
                                               xyz[i][2]),
                file=ofile)

    elif outputformat == "subsys":
        print(
            "##### Include it to the main cp2k.inp using: @INCLUDE '%s.subsys'"
            % outputfilename,
            file=ofile)
        print("  &SUBSYS", file=ofile)
        print("    &CELL", file=ofile)
        print("      PERIODIC XYZ", file=ofile)
        print("      MULTIPLE_UNIT_CELL 1 1 1", file=ofile)
        print("      SYMMETRY NONE", file=ofile)
        print(
            "      A [angstrom] %8.5f %8.5f %8.5f" % (cell.item(
                (0, 0)), cell.item((0, 1)), cell.item((0, 2))),
            file=ofile)
        print(
            "      B [angstrom] %8.5f %8.5f %8.5f" % (cell.item(
                (1, 0)), cell.item((1, 1)), cell.item((1, 2))),
            file=ofile)
        print(
            "      C [angstrom] %8.5f %8.5f %8.5f" % (cell.item(
                (2, 0)), cell.item((2, 1)), cell.item((2, 2))),
            file=ofile)
        print("    &END CELL", file=ofile)
        print(" ", file=ofile)
        print("    &COORD", file=ofile)
        print("      SCALED .FALSE.", file=ofile)
        for i in range(0, natoms):
            print(
                "%3s %9.5f %9.5f %9.5f " % (atom[i], xyz[i][0], xyz[i][1],
                                            xyz[i][2]),
                file=ofile)
        print("    &END COORD", file=ofile)
        print(" ", file=ofile)
        for i in range(0, len(atom_count)):
            if atom_count[i] != 0:
                print("    &KIND %s" % (atomic_symbol[i]), file=ofile)
                print("      BASIS_SET %s" % (args.bscp2k), file=ofile)
                print("      POTENTIAL GTH-PBE", file=ofile)
                print("    &END KIND", file=ofile)
                print(" ", file=ofile)
        print("  &END SUBSYS", file=ofile)

    elif outputformat == "axsf":
        print("ANIMSTEPS 1", file=ofile)
        print("CRYSTAL", file=ofile)
        print("PRIMVEC 1", file=ofile)
        print(
            "     %8.5f %8.5f %8.5f" % (cell.item((0, 0)), cell.item(
                (0, 1)), cell.item((0, 2))),
            file=ofile)
        print(
            "     %8.5f %8.5f %8.5f" % (cell.item((1, 0)), cell.item(
                (1, 1)), cell.item((1, 2))),
            file=ofile)
        print(
            "     %8.5f %8.5f %8.5f" % (cell.item((2, 0)), cell.item(
                (2, 1)), cell.item((2, 2))),
            file=ofile)
        print("PRIMCOORD 1", file=ofile)
        print("%d 1" % (natoms), file=ofile)
        for i in range(0, natoms):
            print(
                "%3s %8.3f %8.3f %8.3f " % (atom[i], xyz[i][0], xyz[i][1],
                                            xyz[i][2]),
                file=ofile)
    else:
        sys.exit("WARNING: Output file format not implemented. EXIT.")

    ofile.close()
