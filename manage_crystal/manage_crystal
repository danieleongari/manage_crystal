#!/usr/bin/env python
from __future__ import print_function
from __future__ import absolute_import
import string, sys
import numpy as np
from numpy.linalg import inv
import math
import subprocess
import argparse
from argparse import RawTextHelpFormatter  #needed to go next line in the help text
import os
import re  #re.split(r'(\d+)',"O23") = ['O', '23', '']
from six.moves import range
from manage_crystal import Crys
from manage_crystal.atomic_data import *  #import all the data stored in the file atom_data.py
from manage_crystal.file_parser import parse_axsf, parse_cif, parse_cp2k
from manage_crystal.file_parser import parse_cssr, parse_cube
from manage_crystal.file_parser import parse_pdb, parse_poscar, parse_pwo
from manage_crystal.file_parser import parse_xyz, parse_xyz_tm3
from manage_crystal.file_writer import write_axsf, write_cif, write_cssr
from manage_crystal.file_writer import write_pdb, write_pwi, write_subsys
#from pprint import pprint #pprint(vars(your_object))

parser = argparse.ArgumentParser(
    description=
    'Program to read, extract info and convert crystal files (by Daniele Ongari)',
    formatter_class=RawTextHelpFormatter)

# File input / output
parser.add_argument(
    "inputfile",
    type=str,
    help="path to the input file to read\n" +
    "IMPLEMENTED: xyz(w/CELL),pdb,cssr,pwi,pwo,cif,xsf,axsf,subsys(CP2K),\n" +
    "             restart(CP2K),inp(CP2K),cube,POSCAR(VASP) \n" +
    "             [NEXT: gaussian, dcd+atoms]")

parser.add_argument(
    "-resp",
    action="store",
    type=str,
    dest="resp",
    default=None,
    help="Read the charges from a cp2k RESP file\n" +
    "(also checking if the atoms are the same)\n" +
    "BC1: it read the first set of charges\n" +
    "BC2: Also a cp2k output file with charges is fine!\n")

parser.add_argument(
    "-readcharge",
    action="store",
    type=str,
    dest="readcharge",
    default=None,
    help="Read the charges from a simple list")

parser.add_argument(
    "-readrepeatcharge",
    action="store",
    type=str,
    dest="readrepeatcharge",
    default=None,
    help="Read the charges from REPEAT output of QE")

parser.add_argument(
    "-o",
    "--output",
    action="store",
    type=str,
    dest="output",
    default=None,
    help="Output filename.extension or just the extension\n" +
    "IMPLEMENTED: cif,pdb,cssr,xyz(w/CELL),pwi,subsys(CP2K),axsf")

# Read settings
parser.add_argument(
    "-pseudopw",
    action="store",
    type=str,
    dest="pseudopw",
    default="pbe",
    help="Pseudo for the .pwi output")

parser.add_argument(
    "-bscp2k",
    "--basisset-cp2k",
    action="store",
    type=str,
    dest="bscp2k",
    default="DZVP-MOLOPT-SR-GTH",
    help="Gaussian Basis Set for CP2K")

arser.add_argument(
    "-potcp2k",
    "--potential-cp2k",
    action="store",
    type=str,
    dest="potcp2k",
    default="GTH-PBE",
    help="Pseudo potential for CP2K")

parser.add_argument(
    "-chargenull",
    action="store_true",
    dest="chargenull",
    default=False,
    help="Delete the charge of the atoms")

# Verbosity section
parser.add_argument(
    "-silent",
    action="store_true",
    dest="silent",
    default=False,
    help="No output info on the screen")

parser.add_argument(
    "-show",
    action="store_true",
    dest="show",
    default=False,
    help="Show all the info\n" + "[skip -silent]")

parser.add_argument(
    "-showonly",
    action="store",
    type=str,
    dest="showonly",
    default=None,
    help="Show only the required info:\n" + "cell, CELL, xyz, fract, charge\n"
    + "[skip -silent]")

parser.add_argument(
    "-printatoms",
    action="store_true",
    dest="printatoms",
    default=False,
    help="Print all atoms types\n" + "[skip -silent]")

parser.add_argument(
    "-printatoms_noHCO",
    action="store_true",
    dest="printatoms_noHCO",
    default=False,
    help="Print all atoms types exc. H,C,O\n" + "[skip -silent]")

# Find/compute stuff section
parser.add_argument(
    "-cutoff",
    action="store",
    type=float,
    dest="cutoff",
    default=None,
    help="Automatically extend the UC so that the cutoff is respected\n" +
    "(TIP: use -cutoff 0 to just know the perpendicular widths!)")

parser.add_argument(
    "-cupw",
    action="store_true",
    dest="cupw",
    default=False,
    help="Look for a Copper PaddleWheel")

parser.add_argument(
    "-ovlp",
    action="store_true",
    dest="ovlp",
    default=False,
    help="Look for an overlap and modify the file [WORK IN PROGRESS]")

mod_coord_cell = parser.add_argument_group("Options to modify coord./cell")
mod_coord_cell.add_argument(
    "-x",
    action="store",
    type=int,
    dest="multipl_x",
    default=1,
    help="Extend in the x direction, by the specified times")

mod_coord_cell.add_argument(
    "-y",
    action="store",
    type=int,
    dest="multipl_y",
    default=1,
    help="Extend in the y direction, by the specified times")

mod_coord_cell.add_argument(
    "-z",
    action="store",
    type=int,
    dest="multipl_z",
    default=1,
    help="Extend in the z direction, by the specified times")

mod_coord_cell.add_argument(
    "-transl",
    action="store",
    type=float,
    nargs=3,
    dest="transl",
    default=None,
    help="x y z translation in Angs")

mod_coord_cell.add_argument(
    "-rotaxis",
    choices=[None, "up", "down"],
    dest="rotaxis",
    default=None,
    help="Rotate the axis. 'up': xyz>zxy, 'down': xyz>yzx")

mod_coord_cell.add_argument(
    "-randomize",
    action="store",
    type=float,
    dest="randomize",
    default=None,
    help="Randomize the geometry by a gaussian\n" +
    "with the specified delta (angs)")

parser.add_argument(
    "-chkmetalcharge",
    action="store_true",
    dest="chkmetalcharge",
    default=False,
    help="Check if the charge on a metal (see list) is neg.\n" +
    "[skip -silent]")

parser.add_argument(
    "-normalizecharges",
    action="store_true",
    dest="normalizecharges",
    default=False,
    help="Normalize the charges to have a null total charge.")

parser.add_argument(
    "-tm "
    "--tailormade",
    type=int,
    dest="tm",
    default=0,
    help="Tailor made settings for parsing and writing:\n" +
    " 1 - Deprecated (parse DDEC-CoRE-MOF .cif)\n"
    " 2 - Deprecated (write .cif for EQeq)\n"
    " 3 - Parse .xyz for B. Wells Qeq program\n"
    " 4 - Write .xyz for B. Wells Qeq program\n"
    " 5 - Deprecated (.xyz for B. Wells Qeq program, w/ zero formal charges)\n"
    " 6 - Deprecated (parse .cif from EGULP)\n")

args = parser.parse_args()

###################################################################### UTILITIES

atom_count = [0] * 119  #anything assigned to 0, H_index=1, He_index=2, ...

ANGS2BOHR = 1.88973
AVOGCONST = 6.022E+23


def is_number(s):  #checks if a string is a number or not
    try:
        float(s)
        return True
    except ValueError:
        pass
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass


########################################################################## INPUT
# reading input file: name and format (notice that if there is a path it becomes
# part of the name, to have the output in the same place)
if not os.path.isfile(args.inputfile):
    sys.exit("ERROR: The file %s doesn't exist!" % args.inputfile)
inputfilename = os.path.splitext(args.inputfile)[0]
inputformat = os.path.splitext(args.inputfile)[1][1:]
file = open(inputfilename + "." + inputformat, 'r')
if inputformat in ["axsf", "xsf"]:
    crys = parse_axsf(file)
elif inputformat == "cif":
    crys = parse_cif(file)
elif inputformat in ["subsys", "inp", "restart"]:
    crys = parse_cp2k(file)
elif inputformat == "cssr":
    crys = parse_cssr(file)
elif inputformat == "cube":
    crys = parse_cube(file)
elif inputformat == "pdb":
    crys = parse_pdb(file)
elif inputformat == "POSCAR":
    crys = parse_poscar(file)
elif inputformat in ["pwo", "pwi"]:
    crys = parse_pwo(file)
elif inputformat == "xyz" and args.tm == 0:
    crys = parse_xyz(file)
elif inputformat == "xyz" and args.tm == 3:  # B. Wells Qeq program
    crys = parse_xyz_tm3(file)
else:
    sys.exit("WARNING: Input file format not implemented. EXIT.")
file.close()

crys.check_parse()
crys.compute_atom_count()
######################################################################## Charges

if not args.resp == None:
    if not all(x == 0 for x in crys.atom_charge):
        if not args.silent:
            print(" ... THERE WERE ALREADY CHARGES BUT I'M OVERWRITING THEM!")
    with open(args.resp, "r") as file:
        i = 0
        for line in file:
            data = line.split()
            if len(data) > 3 and data[0] == 'RESP' \
             and data[2] == crys.atom_type[i]:
                crys.atom_charge[i] = float(data[3])
                i += 1
            if i == crys.natom:
                break

if not args.readcharge == None:
    if not all(x == 0 for x in crys.atom_charge):
        if not args.silent:
            print(" ... THERE WERE ALREADY CHARGES BUT I'M OVERWRITING THEM!")
    with open(args.readcharge) as file:
        i = 0
        for line in file:
            crys.atom_charge[i] = float(line.split()[0])
            i += 1

if not args.readrepeatcharge == None:
    if not all(x == 0 for x in crys.atom_charge):
        if not args.silent:
            print(" ... THERE WERE ALREADY CHARGES BUT I'M OVERWRITING THEM!")
    with open(args.readrepeatcharge) as file:
        if not args.silent:
            print("*** CHARGES from QE>REPEAT.out: multiplying by -0.5")
        i = 0
        for line in file:
            data = line.split()
            if (i - 17) >= 0 and (i - 17) < natoms:  # Header of REPEAT.out
                crys.atom_charge[i - 17] = float(data[6]) * (-0.5)
            i += 1

if args.chargenull:
    if not args.silent: print("*** chargenull: DELETING ALL THE CHARGES! ***")
    crys.atom_charge = [0] * crys.natom

if args.normalizecharges:
    if not args.silent: print("")
    if not args.silent: print("*** NORMALIZING CHARGES ***")
    pos_charge = 0
    neg_charge = 0
    for i in range(crys.atom_natoms):
        if crys.atom_charge[i] > 0:
            pos_charge += crys.atom_charge[i]
        else:
            neg_charge += crys.atom_charge[i]

    tot_charge = pos_charge + neg_charge
    tot_abs = pos_charge - neg_charge
    pos_fract = pos_charge / tot_abs

    if not args.silent: print("total charge: %f" % tot_charge)
    if not args.silent: print("positive charges: %f" % pos_charge)
    if not args.silent: print("negative charges: %f" % neg_charge)
    if not args.silent: print("total absolute ch.: %f" % tot_abs)

    for i in range(crys.atom_natoms):
        if crys.atom_charge[i] > 0:
            crys.atom_charge[i] = crys.atom_charge[
                i] - tot_charge * pos_fract * crys.atom_charge[i] / pos_charge
        else:
            crys.atom_charge[i] = crys.atom_charge[i] - tot_charge * (
                1 - pos_fract) * crys.atom_charge[i] / neg_charge

########################################################### Coordinates and cell

if crys.inp_matrix:
    if not args.silent: print("\n Cell parsed as matrix.")
elif crys.inp_lengths_angles:
    if not args.silent: print("\n Cell parsed as lengths and angles.")
crys.compute_both_cell()

if crys.inp_fract:
    if not args.silent: print(" \n Atomic coordinates parsed cartersian.")
elif crys.inp_xyz:
    if not args.silent: print(" \n Atomic coordinates parsed fractional.")
crys.compute_both_coord()

############################################################################ APPLY TRANSLATION / RANDOMIZE
if args.transl != None:
    if not args.silent:
        print("\n*** TRANSLATING coordinates by %f %f %f Angs" %
              (args.transl[0], args.transl[1], args.transl[2]))
    crys.transl_coord(args.transl)

if args.randomize != None:
    if not args.silent:
        print("\n*** RANDOMIZING XYZ coordinates by a normal distrib \
                     with delta=%f Angs" % args.randomize)
    crys.randomize_coord(delta=args.randomize)

if args.rotaxis != None:
    if not args.silent:
        print("\n*** ROTATING axis, direction: %r" % args.rotaxis)
    if not args.silent: print("*** Warning: the cell matrix is not rotated")
    crys.rotate_axis(up=(args.rotaxis == "up"))

#################################################################### CUTOFF TEST
if not args.cutoff == None:  #copied from raspa/framework.c/CellProperties(line:6184)
    if args.multipl_x > 1 or args.multipl_y > 1 or args.multipl_z > 1:
        sys.exit("Why did you ask for both -cutoff and -x -y -z ????")
    crys.compute_perp_width()

    print("\nCUTOFF_TEST | Cutoff: %.1f" % (args.cutoff))
    print("CUTOFF_TEST | Cell perpendicular widths: %.3f %.3f %.3f" %
          (perp_x, perp_y, perp_z))

    # compute how big the cell must be
    args.multipl_x = int(math.ceil(2 * args.cutoff / crys.perp_width[0]))
    args.multipl_y = int(math.ceil(2 * args.cutoff / crys.perp_width[1]))
    args.multipl_z = int(math.ceil(2 * args.cutoff / crys.perp_width[2]))

    if args.multipl_x > 1 or args.multipl_y > 1 or args.multipl_z > 1:
        print("CUTOFF_TEST | Expansion_done: %d %d %d for %s" %
              (args.multipl_x, args.multipl_y, args.multipl_z, args.inputfile))
    else:
        print("CUTOFF_TEST | Expansion_unnecesary: 1 1 1 for %s" %
              (args.inputfile))

############################################################ Temporary converter
natoms = crys.natom
if crys.inp_lengths_angles:
    ABC = crys.length
    abc = crys.angle_rad
elif crys.inp_matrix:
    cell = np.matrix(crys.matrix)
if crys.inp_xyz:
    xyz = crys.atom_xyz
elif crys.inp_fract:
    fract = crys.atom_fract
atom = crys.atom_element
an = crys.atom_atnum
for f in an:
    atom_count[f] += 1
charge = crys.atom_charge
################################################################# CELL EXPANSION
if args.multipl_x > 1:
    crys.expand_k_dir(0, args.multipl_x)
if args.multipl_y > 1:
    crys.expand_k_dir(1, args.multipl_y)
if args.multipl_z > 1:
    crys.expand_k_dir(2, args.multipl_z)

################################################################### COMPUTE INFO
# count atoms
ntypes = 0
for i in range(0, len(atom_count)):
    if atom_count[i] != 0:
        ntypes += 1
        if not args.silent:
            print('\n{0:>5} {1:3} atoms'.format(atom_count[i],
                                                atomic_symbol[i]))

if not args.silent: print(" ---- --- ----- ")
if not args.silent: print('{0:>5} {1:3} atoms'.format(natoms, 'tot'))

#compute volume (http://www.fxsolver.com/browse/formulas/Triclinic+crystal+system+(Unit+cell's+volume))
volume = ABC[0] * ABC[1] * ABC[2] * math.sqrt(
    1 - (math.cos(abc[0]))**2 - (math.cos(abc[1]))**2 - (math.cos(abc[2]))**2 +
    2 * math.cos(abc[0]) * math.cos(abc[1]) * math.cos(abc[2]))
if not args.silent: print("\nVolume: %.3f (Angtrom^3/u.c.)" % volume)

#compute density
weight = 0
for i in range(0, len(atom_count)):
    if atom_count[i] != 0:
        weight += atom_count[i] * atomic_mass[i]  #g/mol_uc
rho = weight / volume / AVOGCONST * 1E+10**3 / 1000  #Kg/m3
if not args.silent:
    print(
        "Density: %.5f (kg/m3), %.5f (g/cm3), %.5f (g/molUC)" %
        (rho, rho / 1000, weight), )

#compute conversion to mol/kg
molkg = 1000 / weight  #mol/g
if not args.silent:
    print("Conversion: 1 molec./u.c. = %.5f (mol/kg)" % (molkg))

#check the NET_CHARGE
if sum(charge) == 0 and max(charge) < 0.001:
    if not args.silent: print("\nNET_CHARGE: all the charges are zero.")
elif abs(sum(charge)) < +0.001:
    if not args.silent: print("\nNET_CHARGE: negligible (|sum|<0.001).")
else:
    if not args.silent:
        print("\nNET_CHARGE: nonzero (%.3f). ***WARNING***" % sum(charge))

#check negative charge on metals [skip -silent]
if args.chkmetalcharge:
    metal_list = [
        "Li", "Be", "Na", "Mg", "Al", "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn",
        "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Rb", "Sr", "Y", "Zr", "Nb", "Mo",
        "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Cs", "Ba", "La", "Hf",
        "Ta", "W"
    ]
    found_met = False
    found_met_neg = False
    found_met_nonzero = False
    found_met_notnumber = False
    for i in range(0, natoms):
        if (atom[i] in metal_list):
            found_met = True
            if math.isnan(charge[i]):
                print("CHK_METAL_CHARGE: not_number >>> %s=%s" % (atom[i],
                                                                  charge[i]))
                found_met_notnumber = True
            elif charge[i] < 0:
                print("CHK_METAL_CHARGE: found_negative >>> %s=%.3f" %
                      (atom[i], charge[i]))
                found_met_neg = True
            elif charge[i] > 0:
                found_met_nonzero = True
        if found_met_notnumber or found_met_neg: break
    if not found_met: print("CHK_METAL_CHARGE: no_metals")
    if found_met and not found_met_neg and not found_met_notnumber and not found_met_nonzero:
        print("CHK_METAL_CHARGE: all_zero")
    if found_met and not found_met_neg and not found_met_notnumber and found_met_nonzero:
        print("CHK_METAL_CHARGE: ok_positive")

#number of electrons
nelectrons = 0
for i in range(0, len(atom_count)):
    if atom_count[i] != 0:
        nelectrons += atom_count[i] * i  #nuber_of_atoms_with_AN*AN
if not args.silent: print("Tot. electrons: %d" % nelectrons)

#print atoms on one line for info
if args.printatoms:
    for i in range(0, len(atom_count)):
        if atom_count[i] != 0:
            print(atomic_symbol[i], end='_')
    print()
if args.printatoms_noHCO:
    for i in range(0, len(atom_count)):
        if atom_count[i] != 0 and atomic_symbol[i]!="H" \
                                     and atomic_symbol[i]!="C" \
                                     and atomic_symbol[i]!="O":
            print(atomic_symbol[i], end='_')
    print()
################################################################################################# OUTPUT OPERATIONS
if args.output == None:  #CHECK IF AN OUTPUT IS DEFINED
    outputfile = 'NOTHING'
else:
    if len(args.output.split(".")) > 1:  #output defined as name.format
        outputfilename = os.path.splitext(args.output)[0]
        outputformat = os.path.splitext(args.output)[1][1:]
        outputfile = outputfilename + "." + outputformat
    else:  #output defined as format
        outputfilename = inputfilename
        outputformat = args.output
        outputfile = outputfilename + "." + outputformat

if not args.silent:
    print("\n***************************************************")
if not args.silent:
    print("  Converting %s to %s" % (inputfilename + "." + inputformat,
                                     outputfile))
if not args.silent:
    print("***************************************************")
if not args.silent: print()

#show and showonly
if args.show:
    print(
        "cell ---------------------------------------------------------------")
if args.show or args.showonly == "cell":
    print("     %10.5f %10.5f %10.5f" % (cell.item((0, 0)), cell.item(
        (0, 1)), cell.item((0, 2))))
if args.show or args.showonly == "cell":
    print("     %10.5f %10.5f %10.5f" % (cell.item((1, 0)), cell.item(
        (1, 1)), cell.item((1, 2))))
if args.show or args.showonly == "cell":
    print("     %10.5f %10.5f %10.5f" % (cell.item((2, 0)), cell.item(
        (2, 1)), cell.item((2, 2))))
if args.show:
    print(
        "CELL (ABC, abc) ----------------------------------------------------")
if args.show or args.showonly == "CELL":
    print(" %10.5f  %10.5f  %10.5f  %10.5f  %10.5f  %10.5f  " %
          (ABC[0], ABC[1], ABC[2], math.degrees(abc[0]), math.degrees(abc[1]),
           math.degrees(abc[2])))
if args.show:
    print(
        "xyz ----------------------------------------------------------------")
if args.show or args.showonly == "xyz":
    for i in range(0, natoms):
        print("%3s %10.5f %10.5f %10.5f " % (atom[i], xyz[i][0], xyz[i][1],
                                             xyz[i][2]))
if args.show:
    print(
        "fract --------------------------------------------------------------")
if args.show or args.showonly == "fract":
    for i in range(0, natoms):
        print("%3s %10.5f %10.5f %10.5f " % (atom[i], fract[i][0], fract[i][1],
                                             fract[i][2]))
if args.show:
    print(
        "charges --------------------------------------------------------------"
    )
if args.show or args.showonly == "charge":
    for i in range(0, natoms):
        print("%3s %10.5f " % (atom[i], charge[i]))
if args.show or args.showonly != None: sys.exit()

#This function checks if there are copper paddlewheels (= a copper atom with a close Cu and 4 close O)
if args.cupw:
    ncupw_act = 0
    ncupw_sol = 0
    ncupw_wrd = 0
    for i in range(0, natoms):
        closeCu = 0
        closeO = 0
        closeX = 0

        if (an[i] == 29):
            for j in range(0, natoms):
                if (j != i):
                    d = [0] * 3
                    s = [0] * 3
                    t = [0] * 3

                    #d[0]=xyz[i][0]-xyz[j][0]
                    #d[1]=xyz[i][1]-xyz[j][1]
                    #d[2]=xyz[i][2]-xyz[j][2]
                    #s[0]=invcell.item((0,0))*d[0]+invcell.item((1,0))*d[1]+invcell.item((2,0))*d[2]
                    #s[1]=invcell.item((0,1))*d[0]+invcell.item((1,1))*d[1]+invcell.item((2,1))*d[2]
                    #s[2]=invcell.item((0,2))*d[0]+invcell.item((1,2))*d[1]+invcell.item((2,2))*d[2]

                    s[0] = fract[i][0] - fract[j][0]
                    s[1] = fract[i][1] - fract[j][1]
                    s[2] = fract[i][2] - fract[j][2]

                    t[0] = s[0] - int(round(s[0]))
                    t[1] = s[1] - int(round(s[1]))
                    t[2] = s[2] - int(round(s[2]))

                    d[0] = cell.item((0, 0)) * t[0] + cell.item(
                        (1, 0)) * t[1] + cell.item((2, 0)) * t[2]
                    d[1] = cell.item((0, 1)) * t[0] + cell.item(
                        (1, 1)) * t[1] + cell.item((2, 1)) * t[2]
                    d[2] = cell.item((0, 2)) * t[0] + cell.item(
                        (1, 2)) * t[1] + cell.item((2, 2)) * t[2]

                    mindist = math.sqrt(d[0]**2 + d[1]**2 + d[2]**2)

                    if (an[j] == 29) and (1.8 < mindist < 2.8):
                        closeCu += 1
                        #print("%d %d %f     %d %d" %(i,j,mindist,closeO,closeX)
                    if (an[j] == 8) and (1.5 < mindist < 2.5): closeO += 1
                    if (an[j] != 29) and (an[j] != 8) and (1.8 < mindist <
                                                           2.5):
                        closeX += 1
                        #print("%d %d %s  %f------%f %f %f " %(i,j,an[j],mindist,s[0],s[1],s[2]); print(fract[i]; print(fract[j]

            if (closeCu == 1) and (closeO == 4):
                ncupw_act += 1
                #elif (closeCu==1) and (closeO==4) and (closeX>0):  ncupw_sol+=1
            elif (closeCu == 1) and (closeO == 5):
                ncupw_sol += 1
            elif (closeCu < 0):
                ncupw_wrd += 1

    print("Cu-paddlewheel activated found:    %d" % ncupw_act)
    print(
        "Cu-paddlewheel solvated  found:    %d   (only Oxygen atoms considered)"
        % ncupw_sol)
    print("Cu-paddlewheel WEIRD     found:    %d" % ncupw_wrd)
    print()

    #print that I found it
    if True:
        ofile = open("000_cupw_found.txt", 'a')
        if (ncupw_act > 0) or (ncupw_act > 0) or (ncupw_wrd < 0):
            print(args.inputfile, file=ofile)
            print(
                "Cu-paddlewheel activated found:    %d" % ncupw_act,
                file=ofile)
            print(
                "Cu-paddlewheel solvated  found:    %d   (only Oxygen atoms considered)"
                % ncupw_sol,
                file=ofile)
            print(
                "Cu-paddlewheel WEIRD     found:    %d" % ncupw_wrd,
                file=ofile)
            print(" ", file=ofile)

    sys.exit()

#This function checks if two atoms overlap because of a bad PBC wrap
if args.ovlp:
    jlist = []
    for i in range(cryst.natom):
        for j in range(i + 1, cryst.natom):
            dist = cryst.dist_ij(i, j)
            if (dist < 0.2):
                print("Overlap found between:")
                print("%3s %9.5f %9.5f %9.5f " % (atom[i], xyz[i][0],
                                                  xyz[i][1], xyz[i][2]))
                print("%3s %9.5f %9.5f %9.5f " % (atom[j], xyz[j][0],
                                                  xyz[j][1], xyz[j][2]))
                if atom[i] == atom[
                        j]:  #the two atoms are the same and they are overlapping
                    jlist.append(j)
                else:  #something weird is happening, two different atoms are overlapping
                    print(
                        "!!!!!! CHECK THE CRYSTAL, DIFFERENT ATOMS OVERLAPPING !!!!!!"
                    )
                    sys.exit(
                        "!!!!!! CHECK THE CRYSTAL, DIFFERENT ATOMS OVERLAPPING !!!!!!"
                    )

    if len(jlist) > 0:  #correct overlaps
        natoms = natoms - len(jlist)
        atom = [i for j, i in enumerate(atom) if j not in jlist]
        an = [i for j, i in enumerate(an) if j not in jlist]
        xyz = [i for j, i in enumerate(xyz) if j not in jlist]
        fract = [i for j, i in enumerate(fract) if j not in jlist]
        charge = [i for j, i in enumerate(charge) if j not in jlist]
        print("OVERLAPS FOUND: %d" % len(jlist))
        #continue and overwrite the file
        outputfile = args.inputfile
        outputformat = args.inputfile.split(".")[-1]
    else:
        print("OVERLAPS FOUND: %d" % len(jlist))
        sys.exit()

############################################################################## Write converted files
if args.output != None:
    ofile = open(outputfile, 'w+')
    if outputformat == "axsf":
        write_axsf(ofile)
    elif outputformat == "cif":
        write_cif(ofile, crys)
    elif outputformat == "cssr":
        write_cssr(ofile, crys)
    elif outputformat == "pdb":
        write_pdb(ofile, crys)
    elif outputformat == "pwi":
        if not args.silent:
            print("QE input using the pseudo: %s" % (args.pseudopw))
        write_subsys(ofile, crys, args.pseudopw)
    elif outputformat == "subsys":
        if not args.silent:
            print("CP2K input using the BASIS_SET: %s" % (args.bscp2k))
            print("CP2K input using the POTENTIAL: %s" % (args.potcp2k))
        write_subsys(ofile, crys, outputfilename, args.bscp2k, args.potcp2k)
    elif outputformat == "xyz" and args.tm == 0:
        write_xyz(ofile, crys)
    elif outputformat == "xyz" and args.tm == 4:
        write_xyz_tm4(ofile, crys)
    else:
        sys.exit("WARNING: Output file format not implemented. EXIT.")
    ofile.close()
